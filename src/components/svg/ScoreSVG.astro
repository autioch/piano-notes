---
import type { Score as ScoreType, Note as NoteType } from "../../types/piano";
import TrackSVG from "./TrackSVG.astro";
const { score } = Astro.props as { score: ScoreType };

// Layout constants (mm) for A4
const pageW = 210;
const pageH = 297;
const margin = 15; // mm
const usableW = pageW - margin * 2;
const usableH = pageH - margin * 2;

// Helper: parse pitch -> MIDI number (basic support for C0..G9 with optional #/b)
function noteNameToMidi(name: string): number | null {
  const m = name.match(/^([A-Ga-g])([#b]?)(-?\d+)$/);
  if (!m) return null;
  const letter = m[1].toUpperCase();
  const accidental = m[2];
  const octave = parseInt(m[3], 10);
  const baseMap: Record<string, number> = {
    C: 0,
    D: 2,
    E: 4,
    F: 5,
    G: 7,
    A: 9,
    B: 11,
  };
  let pitchClass = baseMap[letter];
  if (accidental === "#") pitchClass += 1;
  if (accidental === "b") pitchClass -= 1;
  const midi = (octave + 1) * 12 + pitchClass; // C4 = 60
  return midi;
}

// Collect all pitches and convert to numbers where possible
const pitchesSet = new Set<number | string>();
for (const t of score.tracks) {
  for (const n of t.notes) {
    pitchesSet.add(n.pitch);
  }
}

// Convert to numeric mapping where possible; keep original string keys where necessary
const pitchesArray = Array.from(pitchesSet);
// Try to map to midi for ordering
const pitchToMidi = new Map<string | number, number>();
for (const p of pitchesArray) {
  if (typeof p === "number") pitchToMidi.set(p, p);
  else {
    const m = noteNameToMidi(p);
    pitchToMidi.set(p, m ?? 60);
  }
}

// Sort unique pitches descending (higher pitches on top)
const sortedPitches = pitchesArray.slice().sort((a, b) => {
  const ma = pitchToMidi.get(a) ?? 60;
  const mb = pitchToMidi.get(b) ?? 60;
  return mb - ma;
});

const laneHeight = usableH / Math.max(1, sortedPitches.length);

// Time range: compute end beat
let endBeat = 0;
for (const t of score.tracks) {
  for (const n of t.notes) {
    endBeat = Math.max(endBeat, n.start + n.duration);
  }
}
if (endBeat === 0) endBeat = 4;

const timeToX = (beat: number) => margin + (beat / endBeat) * usableW;
const beatToWidth = (b: number) => (b / endBeat) * usableW;

// Color mapping: give each distinct pitch a unique color (HSL)
const pitchIndex = new Map<string | number, number>();
sortedPitches.forEach((p, i) => pitchIndex.set(p, i));
const pitchToColor = (p: number | string) => {
  const idx = pitchIndex.get(p) ?? 0;
  const hue = Math.round((idx / Math.max(1, sortedPitches.length)) * 360);
  return `hsl(${hue} 70% 55%)`;
};

const pitchToY = (p: number | string) => {
  const idx = pitchIndex.get(p) ?? 0;
  // center of lane
  return margin + idx * laneHeight + laneHeight / 2;
};
---

<svg
  xmlns="http://www.w3.org/2000/svg"
  width={`${pageW}mm`}
  height={`${pageH}mm`}
  viewBox={`0 0 ${pageW} ${pageH}`}
  style="background:#fff;"
>
  <!-- page border for debugging when printing -->
  <rect
    x={0.5}
    y={0.5}
    width={pageW - 1}
    height={pageH - 1}
    fill="white"
    stroke="#ccc"
    stroke-width={0.5}></rect>

  <!-- title -->
  <text x={margin} y={margin - 4} font-size={14} font-weight="700"
    >{score.title ?? "Untitled"}</text
  >

  <!-- pitch labels on left -->
  <g transform={`translate(${margin - 8}, 0)`} font-size={8} text-anchor="end">
    {
      sortedPitches.map((p) => (
        <text x={0} y={pitchToY(p) + 3}>
          {typeof p === "number" ? p : p}
        </text>
      ))
    }
  </g>

  <!-- time axis top -->
  <g transform={`translate(0, ${margin - 2})`} font-size={8} fill="#333">
    {
      Array.from({ length: Math.min(16, Math.ceil(endBeat) + 1) }).map(
        (_, i) => {
          const bx = timeToX(i);
          return (
            <g>
              <line
                x1={bx}
                x2={bx}
                y1={margin}
                y2={pageH - margin}
                stroke="#eee"
                stroke-width={0.4}
              />
              <text x={bx + 2} y={margin - 2} font-size={7}>
                {i}
              </text>
            </g>
          );
        }
      )
    }
  </g>

  <!-- tracks -->
  <g transform={`translate(${margin}, ${margin})`}>
    {
      score.tracks.map((t, ti) => (
        <g transform={`translate(0, ${ti * (laneHeight + 6)})`}>
          <TrackSVG
            track={t}
            pitchToY={(p) => pitchToY(p)}
            pitchToColor={(p) => pitchToColor(p)}
            timeToX={(b) => timeToX(b)}
            beatToWidth={(b) => beatToWidth(b)}
            laneHeight={laneHeight}
          />
        </g>
      ))
    }
  </g>
</svg>
